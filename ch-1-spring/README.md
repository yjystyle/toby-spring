## 스프링의 IoC
### 어플리케이션 컨텍스트와 설정정보
* 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 부른다.
* 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 말하기도 한다.
* 그리고 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다.
* 보통 빈 팩토리라는 이름보다는 이를 좀 더 확장한 어플리케이션 컨텍스트를 주로 사용한다.
* 어플리케이션 컨텍스트는 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계설정 등의 제어 작업을 총괄한다.

### 애플리케이션 컨텍트스의 동작방식
* 기존에 오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트.
* 스프링에서는 애플리케이션 컨텍스트를 IoC 컨테이너나 스프링 컨테이너라고 부른다. 혹은 빈팩토리.
* @Configuration이 붙은 DaoFactory는 애플리케이션 컨텍스트가 활용하는 IoC 설정정보이다.
* 내부적으로는 애플리케이션 컨텍스트가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달해준다.

## 그렇다면 DaoFactory가 아닌 애플리케이션 컨텍스트를 사용했을때의 이점은?
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
  * 이 부분은 좀 의문이 간다. 분명히 클라이언트에 아래와 같이 DaoFactory.class가 존재하기 때문이다.

    ```
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    ```
* 애플리케이션 컨텍스틑 종합 IoC 서비스를 제공해준다.
* 애플리케이션 컨텟트는 빈을 검색하는 다양한 방법을 제공한다.

### 스프링 IoC의 용어 정리
* 빈
  * 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻. managed object.
* 빈 팩토리
  * 스프링의 IoC를 담당하는 핵심 컨테이너. 
  * 빈 등록, 생성, 조회, 및 부가적인 기능 담당
  * 보통은 애플리케이션 컨텍스트 이용
* 애플리케이션 컨텍스트
  * 빈 팩토리를 확장한 IoC 컨테이너.
  * 빈 팩토리 + 스프링이 제공하는 부가 서비스
* 설정정보/설정 메타정보
  * IoC를 적용하기 위해 사용하는 메타정보
* 컨테이너 혹은 IoC 컨테이너
  * IoC방식으로 빈을 관리하는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 한다.
  
## 싱글톤 레지스트리와 오브젝트 스코프
* `DaoFactory`클래스의 `userDao()` 메서드는 호출시마다 서로 다른 오브젝트를 반환한다.
* 그러나 애플리케이션 컨텍스트에 DaoFactory를 설정정보로 등록하고 getBean() 메소드를 이용해 `userDao()` 메소드를 호출하면 매번 같은 오브젝트가 반환된다.
### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
* 스프링에서 별다른 설정이 없으면 내부에서 생성하는 빈 오브젝트는 모두 싱글톤이다.
* 자바 엔터프라이즈기술을 적용하는 서버 환경에서 매 클라이언트의 요청이 많아지면 서버에 부하를 준다.
* 그래서 일찍이 **서비스 오브젝트**라는 개념을 사용해왔다. 그 예로 **서블릿**이 있다.
* 스펙에서 강제하지 않지만 **서블릿**은 멀티스레드 환경에서 싱글톤으로 동작한다.

### 싱글턴 패턴의 한계
* private 생성자를 갖고 있기 때문에 상속할 수 없다. 따라서 다형성을 적용할 수 없다.
* 테스트하기 힘들다.
* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
* 싱글톤의 사용은 전역(global) 상태를 만들 수 있기 때문에 바람직하지 못하다.
  * 사용하는 클라이언트가 정해져 있지 않다.

### 싱글톤 레지스트리
* 그래서 스프링에서는 위의 한계를 극복하고자 **싱글톤 레지스트리**라는 기능을 제공한다.
* 평범한 자바 클래스라도 IoC방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.
* 오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 **애플리케이션 컨텍스트**에 있기 때문이다.

### 싱글톤과 오브젝트의 상태
* stateless 방식으로 만들어져야 한다.
  * 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것이 매우 위험하기 때문이다.
  
### 스프링 빈의 스코프
* prototype 스코프 : 빈 요청시 매번 새로운 오브젝트 생성
* request 스코프 : HTTP 요청이 생길때마다 생성
* session 스코프 : 웹의 세션과 스코프가 유사

## 의존관계 주입(DI)
### 의존관계란?
* 클래스 A가 클래스 B에 의존하고 있는 경우
    * 대표적인 예는 A가 B를 사용하는 경우, 예를 들어 A에서 B에 정의된 메소드를 호출해서 사용하는것.
* B가 변하면 A에도 영향을 미친다. 반대로 B는 A에 의존하지 않는다.

### UserDao의 의존관계
* 모델의 관점에서 `UserDao`의 겨우 `ConnectionMaker` 인터페이스에만 직접 의존하고
* `DConnectionMaker`라는 클래스의 존재조차 알지 못한다.
* 하지만 런타임시에 `UserDao`는  `DConnectionMaker`에 의존하고 있다. 이를 **런타임 의존관계** 또는 **오브젝트 의존관계**라고 한다.
* 런타임 시점의 의존관계는 위에서 보듯이 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
* 의존관계를 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

### UserDao의 의존관계 주입
* `DaoFactory`는 런타임 시점이 `UserDao`가 사용할 `ConnectionMaker`타입의 오브젝트를 결정하고 이를 생성한 후에 `UserDao`의 생성자 파라미터로 주입해서 `UserDao`가 `DConnectionMaker`의 오브젝트와 런타임 의존관계를 맺게 해준다.
* 이는 두 오브젝트 사이의 런타임 의존관계를 설정해주는 의존관계 주입 작업을 주도하는 존재이자
* 동시에 IoC방식으로 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너다.
* 따라서 의존관계 주입을 담당하는 컨테이너라고 볼 수 있고, 줄여서 DI컨테이너라고 하는데, 
* 그 근간이 되는 개념인 IoC와 함께 사용하여 IoC/DI 컨테이너라는 식으로 사용한다.
* DI컨테이너(`DaoFactory`)에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 메소드(생성자)를 통해 DI컨테이너가 UserDao에게 주입해주는 것과 같다고 해서 이를 의존관계 주입이라고 한다.
  
### 의존관계 검색과 주입
* 일반적으로 스프링 API가 직접적으로 사용된 의존관계 검색방법보다는 의존관계 주입이 코드가 단순하고 깔끔하지만
* 어쩔 수 없이 의존관계 검색을 사용해야 할 경우가 있다.
  * 스태틱 메소드인 main()에서는 DI를 이용하여 오브젝트를 주입받을 방법이 없다.
  * 서버에서는 main()과 같은 기동 메소드는 없지만 사용자의 요청을 받을때마다 main() 메소드와 비슷한 역하을 하는 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다.